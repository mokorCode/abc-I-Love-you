<template>
  <topNav v-if="global.paused"></topNav>
  <div class="gaming-block-black" ref="gamingBlockBlack"></div>
  <div class="gaming-block-white" ref="gamingBlockWhite"></div>

  <div class="gaming-chapter"></div>
  <div class="gaming-dialog fadeIn" @click="dialogSkip">
    <p class="text" ref="text"></p>
  </div>
  <div class="gaming-roleLeft fadeIn"></div>
  <div class="gaming-roleCenter fadeIn"></div>
  <div class="gaming-roleRight fadeIn"></div>
  <div class="gaming-bg fadeIn"></div>
</template>

<script setup name="Gaming">
import topNav from "@/components/UI/topNav.vue";
import { globalData } from "@/utils/globalData";
import { sentenceContext, roles } from "./context";
import { computed, ref, watch } from "vue";
import { storeToRefs } from "pinia";
import { easeOut, linear, easeIn } from "@/utils/animation";

const global = globalData();
const { indexInf } = storeToRefs(global); // 进度信息如 chapter - 0 - 0 - 0
const text = ref(null);
let sentenceIndex = ref(0); // 句子索引
let textFinished = ref(false);
let printMachine = null;
let printMachineIndex = 0;
let textNode = "";
let isDialogSkip = false;
let printMachineFrequency = 50;
const gamingBlockWhite = ref(null);
const gamingBlockBlack = ref(null);

const currentChapter = computed(() => indexInf.value.chapter);
const currentSection = computed(() => indexInf.value.section);
const currentSentence = computed(() => indexInf.value.sentence);

const sentenceText = computed(
  () =>
    sentenceContext[indexInf.value.chapter][indexInf.value.section].sentences[
      sentenceIndex.value
    ]?.text,
); // 当前Text

function dialogSkip() {
  if (!isDialogSkip) {
    isDialogSkip = true;
  }
  if (textFinished.value) {
    sentenceIndex.value += 1;
  }
}

function textPrinter() {
  if (sentenceText.value) {
    printMachine = setInterval(() => {
      textNode += sentenceText.value[printMachineIndex];
      text.value.innerHTML = textNode;
      printMachineIndex += 1;
      if (isDialogSkip) {
        printMachineIndex = sentenceText.value.length;
        text.value.innerHTML = sentenceText.value;
      }
      if (printMachineIndex >= sentenceText.value.length) {
        textFinished.value = true;
        clearInterval(printMachine);
      }
    }, printMachineFrequency);
  }
}

function blockApply(color, animation, duration, reserve) {
  let t = 0;
  let progress = 0;
  const target = {
    white: gamingBlockWhite.value,
    black: gamingBlockBlack.value,
  }[color];
  const easingFunction = { easeOut, easeIn, linear }[animation];
  const effectApplier = setInterval(() => {
    progress = t / duration;
    if (progress >= 1) {
      target.style.opacity = reserve
        ? 1 - easingFunction(1)
        : easingFunction(1);
      clearInterval(effectApplier);
    }
    target.style.opacity = reserve
      ? 1 - easingFunction(progress)
      : easingFunction(progress);
    t += 16;
  }, 16);
}
async function dealEffects() {
  const currentEffects =
    sentenceContext[currentChapter.value][currentSection.value].sentences[
      sentenceIndex.value
    ]?.effects;
  if (!currentEffects) return; // currentEffects 不存在, 终止
  for (let i = 0; i < currentEffects.length; i++) {
    const effect = currentEffects[i];
    console.log(effect); // debug
    if ("blackBlock" in effect) {
      await blockApply(
        "black",
        effect.blackBlock,
        effect.duration,
        effect.reserve,
      );
    } else if ("whiteBlock" in effect) {
      await blockApply(
        "white",
        effect.whiteBlock,
        effect.duration,
        effect.reserve,
      );
    }
  }
}

watch(
  () => [indexInf.value, sentenceIndex.value],
  async () => {
    console.log("进度变化！");
    console.log(indexInf.value);

    gamingBlockBlack.value.style.color = "white";
    gamingBlockBlack.value.innerText = `${JSON.stringify(sentenceContext[indexInf.value.chapter][indexInf.value.section].sentences[sentenceIndex.value])}`; // debug
    textFinished.value = false;
    textNode = "";
    printMachineIndex = 0;
    printMachine = null;
    isDialogSkip = false;
    printMachineFrequency = 50;
    await dealEffects();
    textPrinter();
  },
  { deep: true },
);
</script>
<style scoped></style>
